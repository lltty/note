### 为什么需要复杂度分析
通过统计、监控、就能拿到算法执行的时间和占用的内存大小。这种叫事后统计法，有很大的局限性。测试结果依赖测试环境，测试结果受到数据规模的影响很大。复杂度分析是不需要具体的测试数据，就可以粗略的估算执行效率的方法。

大O时间复杂度表示法： T(n) = O(f(n)),大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫做渐进时间复杂度，简称时间复杂度。当n很大时，公式中的低阶，常量，系数三部分并不左右趋势，可以忽略。

### 时间复杂度分析的方法：

1. 只关注循环执行次数最多的代码

2. 加法法则:总复杂度等于量级最大的那段代码的复杂度

```
int cal(int n) {
    int sum_1 = 0;
    int p = 1;
    for (; p < 100; ++p) {
        sum_1 = sum_1 + p;
    }

    int sum_2 = 0;
    int q = 1;
    for (; q < n; ++q) {
        sum_2 = sum_2 + q;
    }
    
    int sum_3 = 0;
    int i = 1;
    int j = 1;
    for (; i <= n; ++i) {
        j = 1; 
        for (; j <= n; ++j) {
            sum_3 = sum_3 +  i * j;
        }
    }
    
    return sum_1 + sum_2 + sum_3;
}
```
算法复杂度：

T1(n) = O(f(n)), T2(n) = O(g(n)), T3(n) = O(h(n))
T1(n) = O(100), T2(n) = O(n), T3(n) = O(n²)
T1(n)的算法复杂度是常量，忽略
T(n) = T2(n) +  T3(n) = MAX(g(n), h(n)) = MAX(O(n), O(n²)) = O(n²)


3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码的复杂度的乘积
```$xslt
int cal(int n) {
   int ret = 0; 
   int i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i);
   } 
 } 
 
 int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  } 
  return sum;
 }
```

算法复杂度：
Tn = T1(n) * T2(n) = O(n) * O(n) = O(n²)

4 最好情况时间复杂度，最快情况时间复杂度，求出平均情况时间复杂度作为算法的复杂度
```$xslt

// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) 
      pos = i;
      break;
  }
  return pos;
}

```
这是一个在数组中查找数据的函数，最好情况第一个就是x,时间复杂度O(1)，最坏情况最后一个才是，时间复杂度O(n),按照平均时间复杂度方法进行计算：

1 值x在数组中存在位置为0~n-1加上不存在，所有情况是n + 1种
2 每种情况，需要遍历的元素个数累加：1 + 2 + 3 + n + n
3 计算平均值：
 1 + 2 + 3 + n + n     (1 + n) * n + n    n(n + 2)    n²
 ----------------- =  --------------- =  -------- =  ---- = n
 n + 1                     2(n+1)         2(n+1)      2n 
所以算法的平均复杂度是O(n)

5 均摊时间复杂度：
```$xslt

 // array表示一个长度为n的数组
 // 代码中的array.length就等于n
 int[] array = new int[n];
 int count = 0;
 
 void insert(int val) {
    if (count == array.length) {
       int sum = 0;
       for (int i = 0; i < array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }

    array[count] = val;
    ++count;
 }
```
这是一个数组插入函数，但是当数据满了之后，就将所有值求和，放入第一个元素，将当前元素放入第二个元素。
最好情况，数据有空闲，时间复杂度O(1), 最快情况，数组满了，需要遍历所有元素求和，时间复杂度O(n),往数组里插入值的情况总共有n+1种,而且每种发生的概率都是一样的:1/(n+1).每一次最耗时的O(n)操作都会跟随n-1次的O(1)操作，所以将O(n)的时间复杂度平均分摊到后面的n-1次，最后的时间复杂度就是O(1).
O(n)
---
 9

### 常见的复杂度量级
![复杂度量级](所有代码的复杂度量级c95325bf0a.jpg)

分为多项式量级和非多项式量级，非多项式量级包括：指数阶、阶乘阶
当数据规模增大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增大。所以非多项式量级算法是非常低效的。

### 常见的多项式时间复杂度

1. O(1): 一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

2 O(logn)、O(nlogn):
```$xslt

 i = 1;
 while (i <= n)  {
   i = i * 2;
 }
```
变量i的值是等比数列:
2 2² 2³ 2的x次方 = n;2的x次方 = n; x = log2n,所以代码复杂度是：O(log2n)

```$xslt

 i = 1;
 while (i <= n)  {
   i = i * 2;
 }
```
代码复杂度：O(log3n), log3(n) = log3(2) * log2(n) = log2(n),所以对数阶的时间复杂度统一用O(log2(n)),忽略底数，统一用O(㏒n)表示

如果一段代码的时间复杂度是O(㏒n)，那春福执行n遍，时间复杂度就是 O(nlogn) 了

3. O(m+n)、O(m*n)
```$xslt

int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

这段代码的时间复杂度不能按照加法法则，因为无法评估m和n孰大孰小。但是乘法法则有效：T1(m)*T2(n) = O(f(m) * f(n))

#### 空间复杂度
空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系
常见的空间复杂度就是 O(1)、O(n)、O(n2)

#### 数组
数组是一种线性表结构。他用一组连续的内存空间，来存储一组具有相同类型的数据。线性表的数据只要向前和向后两个方向。数组，链表，队列，栈都是线性表结构。

树，堆，图是非线性结构，数据的方向不只是简单的前后关系。

因为数组保存的是相同的数据结构，所以可以实现随机访问：一个长度为10的int数组： int[] a = new int[10],计算机给数组分配的一块连续的内存空间1000~1039,第一个元素占用的内存地址是1000-1003

![数组](10个元素的数组内存空间.jpg)

通过下面的公式：

```$xslt
a[i]_address = base_address + i * data_size
```
第0个元素:  1000 + 0 * 4 = 1000,所以占用了1000 ~ 1003的内存地址
第1个元素:  1000 + 1 * 4 = 1004,所以占用1004 ~ 10007的内存地址

#### 数组和链表的区别
链表适合插入，删除,内存空间不需要重新分配,删除的时间复杂度是O(n),数组适合查找,按照值查找:无序数组查找的时间复杂度是O(n),有序数组查找通过二分查找，时间复杂度是O(log(n)),删除，插入的的话会影响内存重新分配，如果是随机查找时间复杂度是O(1).数组的内存空间是连续的，链表不是连续的

数组中插入元素时候，如果不考虑顺序,为了避免大规模的数据迁移，比较快速的操作是将指定位置的元素移动到数组的末尾，将需要插入的元素插入指定的位置。这样可以将插入元素的时间复杂度降低为O(1)

在某些特殊场景下，并不一定要追求数组中数据的连续性。如果将多次删除操作集中在一起执行，删除的效率就会高很多

比如下面a[10]中存储了a, b, c, d, e,f, g, h,现在要依次删除a,b,c,为了避免d,e,f,g,h这几个数据的多次迁移，我们可以先记录下已经删除的数据。每次的操作并不是真正的删除数据，只是将数据标记为删除。当数组没有更多的空间存储数据时，再触发执行一次真正的删除操作。


#### 二维数组内存寻址

计算机的内存是一维的，多维数组的元素应排成线性序列后存入存储器，二维数组A[m][n]按行优先存储的线性序列为:
A[0][0]、A[0][1]...A[0][n], A[1][0]...A[1][n]...A[m][0]...A[m][n]

所以对于 m * n 的数组，a[i][j] (i < m,j < n)的地址为：

address = base_address + ( i * n + j) * type_size

#### redis使用调表来实现有序集合(还有散列表)

比起单纯的单链表，调表需要存储多级索引，所以需要消耗更多的存储空间。原始链表大小为n,第一级索引大约有n/2个节点，第二级索引有n/4个节点。依次类推，每上升一级就减少一半，直到剩下2个节点。所有节点之和为：
n   n    n
- + -  + - ... + 8 + 4 + 2 = n-2
2   4    8
所以跳表的空间复杂度是O(n).如果要降低跳表的空间复杂度，可以每三个或者5个节点，抽一个节点到上级索引。
跳表插入、删除操作的空间复杂度是O(logN).

跳表索引动态更新：当我们不停的往跳表中插入数据时，如果我们不更新索引，就有可能出现2个索引节点之间数据非常多的情况，极端情况下，跳表还会退化为单链表。作为一种动态数据结构，我们需要某种手段来维护索引于原始链表大小之间的平衡，也就是说，如果链表中节点多了，索引节点就相应的增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。跳表是通过随机函数来维护这种平衡性的。通过一个随机函数来决定插入数据的时候，将索引插入哪些层级中。

### 散列表
散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。
一个数据的标识叫做键或者关键字，将键转化为数组下标的方法叫做散列函数，散列函数计算得到的值叫做散列值或者哈希值。

不存在能够完全避免散列冲突的散列函数。避免散列冲突的方法有开放寻址法和链表法。

开放寻址法的时间复杂度高，而且极端情况下可能退化为O(n)，所以通常使用链表法。对于散列比较均匀的散列函数来说，理论上讲，查找和删除的时间复杂度是O(k).k = n/m,其中n是散列表中数据的个数，m表示表中"槽"的个数。

散列表insert的数据，除了保存数据的value值，还需要保存键值，来便于按照键值来找到存储的数据，如果键值不允许重复，即就是相同键值的数据，后来的覆盖前来的，那么在insert的时候，除了来找到相应的槽位，还在在相应槽位的链表里查找相应的key是否窜在。

### 二叉树
节点的高度：节点到叶子节点的最长路径
节点的深度：根节点到这个节点所经历的边数
节点的层级：节点的深度+1
树的高度：根节点的高度

#### 为何要用二叉树

散列表的操作时间复杂度是O(1),而二叉树在理想的平衡二叉树的情况下，操作的时间复杂度也才是O(logN),那为何要使用二叉树

1 散列表中的数据是无序的，如果要输出有序的数据，需要先排序，而对于二叉查找树，只需要中序遍历即可。

2 散列表的扩容是非常耗时的，因为要牵扯到数据重新散列和保存到新数组。当遇到散列冲突时，性能不稳定,尽管二叉树的性能也不稳定，但是在工程中我们用的是平衡二叉树，它的性能很稳定

3 笼统的讲，尽管散列表查找的时间复杂度是常量级的，但因为hash冲突的存在，这个常量不一定比logN小，而且散列函数是需要耗时的，所以整体而言，性能不一定比二叉树好

#### 红黑树

##### 红黑树的定义

1. 根节点是黑色的；
    
2. 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
    
3. 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
    
4. 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点
    
 插入，删除操作会破坏第4，第5条，也就是平衡性，当平衡性被破坏的时候，是通过围绕某个节点的左旋或者右旋来恢复平衡的。

#### 堆

##### 堆的要求：

1. 堆是一个完全二叉树
2. 堆中的每一个节点的值都必须大于等于(或者小于等于)其子树的值。

节点大于等于其子树的堆叫大顶堆
节点小于等于其子树的堆叫小顶堆

##### 堆的应用

1 优先级队列
2 定时器

##### 几种更加基本的算法
1 贪心算法
针对一组数据，定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。

分配糖果:糖果少，孩子多，糖果大小不一样，孩子对糖果的需求也不一样，先从需求最小的孩子分起，找到满足他的需求的最小糖果。


2 分治算法

3 回溯算法

4 动态规划




























































