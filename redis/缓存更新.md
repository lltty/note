0 redis缓存更新测略：
       1 Read/Write Throuth.读数据，时候，有缓存，被缓存，没缓存的话，读数据库，更新缓存，写请求的时候，读缓存，如果没读到，直接返回，如果读到，更新缓存。
       2 cache aside 的不同之处在于，写请求的时候，不尝试更新缓存，而是直接删除缓存。利用cache aside可以有效的避免并发都写导致的脏数据问题。

01 不管是上面那种情况都会产生缓存雪崩的问题，所以新系统需要对缓存数据预热。或者采取灰度发布的方式。缓存穿透导致数据库雪崩的情况是：缓存失效，如果数据从数据库查询需要很长时间，那这段时间的请求都会打到数据库，导致数据库繁忙。恶意请求不存在的数据，也会导致缓存穿透，这时候就需要对查询的请求做处理。

02 如果要解决缓存穿透,那就需要牺牲缓存的时效性和利用率，缓存所有的数据，放弃read throuth策略，所有的请求只读缓存，不读数据库，后台单独用一个服务来更新缓存。

1  对于像订单服务这类核心的业务，一个可行的方法是：启动一个更新定订单缓存的服务，接收订单变更的MQ消息，然后更新Redis中缓存的订单数据。需要担心的问题，消息丢了怎么办，一旦出现丢消息，缓存里缺失的那条数据永远不会被补上。所以需要保证整个消息链条的可靠性。不过好在fKafka或者MQ都有高可用和高可靠的保证机制，只要正确配置，可以满足数据的可靠性要求。

2 如果要缓存的数据，本来没有一份数据更新的MQ消息订阅怎么办？可以采用，负责更新缓存的服务把自己伪装成一个mysql的从节点，从Mysql接收binlog,解析binlog之后，可以得到实时的数据变更信息，然后根据这个变更去更新redis缓存。这种收Binlog更新缓存的方案和收MQ消息更新缓存的方案，是一样的思路。

3 但是Binlog的解析是一个问题。有开源项目[Cannal](https://github.com/alibaba/canal)提供了订阅和解析Mysql Binlog的功能。

4 Cannal模拟了Mysql主从复制的交互协议，把自己伪装成MYSQL的从节点，向MYSQL主节点发送dump请求。


