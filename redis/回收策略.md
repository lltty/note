maxmemory 100mb #配置redis存储数据时指定限制的内存大小。

maxmemory 为0代表没有内存限制。对于64位的系统，这个是默认值，对于32位的系统默认是3GB.

当指定的内存限制大小达到时，需要选择不同的策略，进行数据回收。

回收策略: 由maxmemory-policy指令进行配置

noeviction: 返回错误，当内存达到上限且客户端尝试执行会让更多内存被使用的命令(del例外)
allkeys-lru: 尝试回收最少使用的键，使得新添加的数据有存放空间
volatile-lru: 尝试回收最少使用的键，但仅限于过期集合的键，使得新添加的数据有存放空间
allkeys-random: 随机回收键
volatile-random: 随机回收过期集合中的键
volatile-ttl: 回收过期集合的键，并且优先回收存活时间(TTL)较短的键。

为键设置过期时间也是需要消耗内存的，所以使用allkeys-lru这种策略更加有效。因为没有必要为键设置过期时间
当内存有压力的时候

redis使用两种算法进行垃圾回收:引用计数和LRU算法
LRU算法是淘汰最久未被使用的数据，使用的数据结构是HashMap + Double LinkedList
redis使用的不是精确的LUR算法，而是随机挑选若干个键，并且从中选取一个最久未被使用的键。在配置文件中可以使用
maxmemory-samples进行设置。

typedef struct redisObject {
    unsigned type:4;
    //内容编码
    unsigned encoding:4;
    //与server.lruclock的时间差值
    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */\
    //引用计数算法使用的引用计数器
    int refcount;
    //数据指针
    void *ptr;
}
server.lruclock 会在定时器每次刷新时，调用getLRULock获取当前系统的毫秒数，作为LRU的时钟。


下面介绍三种删除策略：

定时删除：在这是键的过期时间的同时，创建一个定时器 Timer，让定时器在键过期时间来临时立即执行对过期键的删除。
惰性删除：键过期后不管，每次读取该键时，判断该键是否过期，如果过期删除该键返回空。
定期删除：每隔一段时间对数据库中的过期键进行一次检查。

定时删除：对内存友好，对 CPU 不友好。如果过期删除的键比较多的时候，删除键这一行为会占用相当一部分 CPU 性能，会对 Redis 的吞吐量造成一定影响。

惰性删除：对 CPU 友好，内存不友好。如果很多键过期了，但在将来很长一段时间内没有很多客户端访问该键导致过期键不会被删除，占用大量内存空间。

定期删除：是定时删除和惰性删除的一种折中。每隔一段时间执行一次删除过期键的操作，并且限制删除操作执行的时长和频率。

具体的操作如下：

Redis 会将每一个设置了 expire 的键存储在一个独立的字典中，以后会定时遍历这个字典来删除过期的 key。除了定时遍历外，它还会使用惰性删除策略来删除过期的 key。
Redis 默认每秒进行十次过期扫描，过期扫描不会扫描所有过期字典中的 key，而是采用了一种简单的贪心策略。
从过期字典中随机选择 20 个 key；删除这 20 个 key 中已过期的 key；如果过期 key 比例超过 1/4，那就重复步骤 1。
同时，为了保证在过期扫描期间不会出现过度循环，导致线程卡死，算法还增加了扫描时间上限，默认不会超过 25ms。