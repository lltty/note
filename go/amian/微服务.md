### 微服务概述 
#### 1 聊聊微服务
   首先什么是微服务: 我的理解是把单模块应用拆解成多模块。
   那么为什么要做这件事情，或者说这是一个怎么样的过程:
   假如有两个大学同学，他们都曾经是大学的风云人物，毕业后工作了几年，就决定要自己创业。皮皮立志自己要成为马云那样的男人，朵朵立志要成为董明珠那样的女人。皮皮负责技术，朵朵负责运营。皮皮为了快速实现功能，这时候只需要一个网站，一个后台管理平台，数据库。那网站的话负责用户登陆，商品展示，下单就完事了。管理平台只需要三个功能，用户管理，商品管理，订单管理。数据库的话，找阿里云就好了。
   结果跑了一段时间之后，发现别人也搞起来了。竞争好大，所以为了提高自己的竞争力。我们想了想，我们要做移动端，微信小程序也得高。然后各种活动得搞起来。别人双十一，双十二搞起来了，我们也得高。还得加入广告位提高一些商品的曝光度。我们的商品也不够丰富，我们需要靠谱是否对接第三方平台，来扩展我们的商品库。
   好，我们发现人手不够了，必须喊点自己的好朋友或者同学过来。然后人喊过来了,时间紧迫，时间就是金钱。微信小程序，移动app,网站各自负责自己的业务模块。结果发现很多业务代码都在重复写，而且时常会发现一些，有些数据源，你写我也写，而且数据结构不一致的问题，搞的人很头大。发布的时候，随着功能的复杂度逐渐提高，我们发现发布越来越慢了，我只改了一点点数据响应结构，就几行代码，结果我那个服务整个都要发布。而且数据库大家都用的是一个，不管什么业务的都在同一个库上操作。牵扯到一些耗时操作的时候，即使我们做了主从，写业务在同一个库。我们发现我们的网站，app,微信小程序都很慢了。数据库越来越扛不住。随着时间的积累，大家每次发布功能都很害怕，晚上半夜搞完，测试一波，第二天还得盯着。甚至开发功能的时候，大家开始扯皮，觉得这个业务需要好像是不属于自己的，或者别人那边也能开发，为啥要给自己。日积月累，大家的矛盾越来越深。作为创业者的皮皮和朵朵，这时候都hold不住了。没过两天，皮皮头发就白了。
    眼看着业务越来越差，技术人员的矛盾越来越严重。皮皮开始自责，都是自己的错，自己技术太烂了。看着皮皮如此焦虑，朵朵看在心里。朵朵和皮皮商量，原来自己班里的牛牛在一个大公司做技术，非常牛，要不然把他拉过来，帮我们想想办法。于是乎，他们把牛牛挖过来了。他们和牛牛说了公司目前的现状，牛牛说着确实是一个很严重和紧迫的问题，这是很多创业公司和团队必须要经历的过程。皮皮慌了，说，那咋办，就这样等着公司黄了。牛牛说莫慌，这很正常，有办法的，我们慢慢来。你给我点时间。于是乎，牛牛拉了所有的技术团队，开始讨论我们目前的业务功能，对功能模块进行细分，微服务化。对数据库部分也做了分离，不同业务的数据放到不同的库里，为了避免单点。不同业务的库都做了主从。经过了几个月的奋战。大家对服务进行了拆分，技术各自负责的业务功能也比较明确了，边界相对清晰。数据库的压力也没那么大了。发布也方便了。业务开始慢慢恢复，技术人员也不在那么焦躁了。这时候牛牛跟皮皮汇报说，你看看，现在咋样。皮皮说，牛牛啊，你就是我的救星，以后你就是我们的CTO了。那天晚上，皮皮和牛牛，朵朵。三个人喝酒喝到了天亮。
    但是故事到这里还没有完。牛牛负责了这个公司的技术团队以后。针对这段时间的努力，他对大家表示了感谢，表示过几天，组织团建。同时提出了一个问题,我们这几个月其实一直在搞为服务的东西，那大家现在知道微服务是什么吗？有人回答微服务就是将单模块应用进行拆分。有人说未服务我们要关注服务发现，服务治理，服务通信，网关。有人说我们要考虑微服务带来的服务器成本，运营成本。然后牛牛说，大家说的对，那作为一个开发者，对于微服务我们应该关注什么，或者说认为微服务是什么。大家沉默了。微服务不就是一个软件开发的架构思想么，对开发者而言，这有什么不同么。这时候牛牛发言了:其实作为开发者，我认为微服务应该是一种软件开发的设计模式，它是和MVC并没有什么本质区别。从架构层面说，微服务应该遵循的几个点：服务单独发布，单独管理，服务之间无依赖。服务的数据分离。但是这些依然可以运用在服务内部的设计上，在服务内部，对功能进行细分。比如说我们的服务设计，开始是有一个service。这个服务它只是负责调度，或者说叫数据整合，提供对外的接口访问接口。这是第一层，第二层，应该是各个子功能的services层。第一层调度就是这些子功能。但是随着业的发展，我们我们常常会发现这先子功能层也就是第二层，常常是多个文件，每个文件都非常大，动不动就是7，8千行，甚至更大。这说明我们对第二层的设计不够合理，我们需要对第二层的业务代码，进行细分，继续做功能下沉。我们应该将第二层作为聚合层，将更细粒度的功能放到第三层实现。第二层作为聚合层，调度它的下层。
    但是故事到这里还没有完。牛牛负责了这个公司的技术团队以后。针对这段时间的努力，他对大家表示了感谢，表示过几天，组织团建。同时提出了一个问题,我们这几个月其实一直在搞为服务的东西，那大家现在知道微服务是什么吗？有人回答微服务就是将单模块应用进行拆分。有人说未服务我们要关注服务发现，服务治理，服务通信，网关。有人说我们要考虑微服务带来的服务器成本，运营成本。然后牛牛说，大家说的对，那作为一个开发者，对于微服务我们应该关注什么，或者说认为微服务是什么。大家沉默了。微服务不就是一个软件开发的架构思想么，对开发者而言，这有什么不同么。这时候牛牛发言了:其实作为开发者，我认为微服务应该是一种软件开发的设计模式，它是和MVC并没有什么本质区别。从架构层面说，微服务应该遵循的几个点：服务单独发布，单独管理，服务之间无依赖。服务的数据分离。但是这些依然可以运用在服务内部的设计上，在服务内部，对功能进行细分。比如说我们的服务设计，开始是有一个service。这个服务它只是负责调度，或者说叫数据整合，提供对外的接口访问接口。这是第一层，第二层，应该是各个子功能的services层。第一层调度就是这些子功能。但是随着业的发展，我们我们常常会发现这先子功能层也就是第二层，常常是多个文件，每个文件都非常大，动不动就是7，8千行，甚至更大。这说明我们对第二层的设计不够合理，我们需要对第二层的业务代码，进行细分，继续做功能下沉。我们应该将第二层作为聚合层，将更细粒度的功能放到第三层实现。第二层作为聚合层，调度它的下层。这样即使在服务内部，我们也可以做功能细分。第一层只有一个service，第二层的聚合层可能有一层或者多层。更小粒度的业务代码都在最下层实现。这样我么的设计就会更合理，功能也会更细分，也就会很少存在，我们在写代码的时候，常常会困惑我们的代码到底是写在哪里，是否要单独拆分出来。单时候这时候就会存在一个问题。服务内部，平级别的第二层如果要调用平级别服务的子功能代码，怎么办。这是比较麻烦的地方，有时候聚合层只需要关注自己的业务，但有时候为了对比的模块做支持，我们不得不将原子操作的接口暴露出去，便于别处调用。这虽然增加了少量的工作负担。但是是有好处的。我们可以对数据做收口，同一块业务的只有一个地方可操作，不管读写都是。这样既保证了数据收口，同时保证了数据统一。不会存在比如说像mongo里面的数据，某个字段，有的地方保存了整数，有的地方保存了字符串。或者json数据在数据库里一会保存空，一会保存空数据类似这样的。大家听了以后觉得，嗯，很有道理，纷纷表示了赞同，同时又皱起了眉头，感觉自己的代码似乎很有重构的必要。
      到这里故事就结束了。
      
#### 2 微服务面临的问题 
* 如果某个服务，其他服务都在调用，那么就很有可能因为一个服务的故障，导致整个应用的雪崩 
* 以前是单模块的情况下，我们只需要查看单个服务的日志，调用堆栈，分析就可以很快的找出问题。但是现在服务一层层调用。需要一个个查看，查找问题。查找问题变得复杂
* 日志量急剧暴增，需要相应的日志分析工具，便于日志查看。
* 测试难度的增加，原来单个服务的测试，现在多个服务之间调用，变成多个服务测试。
* 多个服务会导致服务的稳定性降低，故障率更好。

#### 3 如何降低故障率
其实降低故障，一方面是降低故障的发生，一方面是降低故障造成的影响。那就可以从两方面出手：
* 降低故障的发生: 服务限流,事前监控，事后分析。
* 降低故障造成的影响：对服务做容错处理，服务降级。

##### 3.1 服务监控
微服务架构中，组件众多，各个组件需要监控的参数不同。比如redis监控内存占用情况、网络流量。数据库监控连接数、磁盘业务。业务服务监控并发数、响应延迟、错误率等。因为如果做一个大而全的监控系统是不大现实的，而且即使实现了，扩展性不见得很好。一般做法是让各个组件提供报告自己当前状态的接口，这个接口输出数据的格式是一致的。然后部署一个服务，从这些组件拉取这些组件状态，同时提供查询服务。然后还需要一个UI界面,便于从指标采集器查询各项指标以及汇成图表。同时可以设计阀值，根据阀值报警等。

redis和mysql分别有RedisExpoter和MysqlExpoter,这两个组件分别提供了Redis缓存和Mysql数据库的指标接口。微服务则根据各个服务的业务逻辑实现自定义的监控数据。然后使用普罗米休息作为指标采集器，Grafana配置监控界面和邮件告警。这样一套微服务监控系统就搭建起来了。

##### 3.3定位问题 链路跟踪
要实现链路追踪，每次服务调用会在http的HEADERS中记录至少四项数据:
* traceId: 标志一个用户请求的调用链路。具有相同traceId的调用属于同一条链路。
* spanId: 表示一次服务调用的Id,即链路跟踪的节点Id.
* parentId: 父节点spanId.
* requestTime & responseTime: 请求时间和响应时间。 
这样在服务开始启动的时候，比如我们使用的GRPC服务,在启动的时候，就可以开启Opentracing,并配配置服务跟踪的链路日志提交给Zipkin.这样就可以自动收集链路日志了。
如果不这样做，那可能就需要手动对每个服务的请求实现拦截器，在这个拦截器里实现链路跟踪了。比如http需要追加参数到HEADERS.

##### 3.4 日志分析
日志分析组件在微服务兴起之前，就被广泛使用了。即使是单模块应用。当访问量增加时、或服务器规模增多时，日志文件的大小会膨胀到难以用文本编辑器进行访问，更糟糕的是他们分散在多台服务器上面。排查一个问题的时候，需要登录到多台服务器上获取日志文件，筛查想要的日志信息。

  因此在应用规模变大时，需要一个日志搜索引擎。一般可能会使用ELK.
`萌推是怎么实现日志记录的`

##### 3.5 网关-权限控制，服务治理
拆分成为微服务之后，出现了大量的服务，大量的接口，使得调用关系乱糟糟的。经常在开发流程中，写着写着想不起某个数据应该调用哪个接口。或者写歪了，调用了不该调用的接口。这时候就需要再调用方和服务方之间有一个把关的东西，就是网关，每次调用时可以进行权限验证。另外网关也可以作为一个提供服务接口文档的平台。

使用网关有一个问题就是要决定多大粒度的使用，粗粒度的就是整个微服务一个网关，服务外部通过网关调用，服务内部则直接调用；细粒度则是所有调用者，不挂内部还是外部，都必须通过网关调用。折中的方案是按照业务领域将微服务分成几个区，区内直接调用，区间通过网关调用。
`萌推的微服务网关是怎么实现的`:目前使用kong

##### 3.6 服务注册和发现

##### 3.7 熔断、服务降级、限流
###### 3.7.1 熔断
当一个服务因为各种原因停止响应时，调用方通常会等待一段时间，然后超时或者收到错误返回。如果调用链路比较长，可能会导致请求堆积，整条链路资源一直在等待下游响应。所以当多次访问一个服务失败时候，就需要做熔断了,标记该服务已经停止工作，直接返回错误。直至该服务恢复正常后再重新建立连接。

请求开始失败->打开熔断器->当失败达到一定量级的时候，直接返回错误->间隔发送健康检查，当达到健康检查的标准的时候->再正常请求

###### 3.7.2 服务降级
当下游服务停止工作时，如果该服务并非核心服务，则上游服务应该降级。以保证核心业务不中断。比如网上超时下单界面有一个推荐商品凑单的功能，当推荐模块挂了以后，下单功能不能一起挂掉，只需要暂时关闭推荐功能即可，或者打开一个默认设置的缓存。

###### 3.7.3 服务限流
一个服务挂掉之后，上游服务或者用户一般会习惯性的重试。这导致一旦服务恢复正常，很可能因为瞬间网络流量过大由立刻挂掉

##### 3.8 测试
* 端到端测试:覆盖整个系统，一般在用户界面测试
* 服务测试:针对服务接口进行测试
* 单元测试: 针对代码单元进行测试
一般端到端测试,可以对整个系统进行测试，也是最有信心的，当然实现难度也是最大的。当端到端测试失败之后，则需要分析原因，然后编写单元测试来重现这个功能进而修复问题，再继续。服务测试的难度，在于接口依赖，这时候可以通过mock来解决。

#### 4 题外话
通常,rpc要求在调用方中放置被调用的接口。调用方法只要调用了这些接口，就相当于调用了被调用方的实际方法，十分容易。于是，调用方可以像调用内部接口一样调用远程的方法。
首先调用方调用的是接口，必须为接口构造一个实现。显然要使用动态代理。这样，调用方的调用就被动态代理收到了。

动态代理收到调用后，应该想办法调用远程的实际实现,这就包括：
* 识别具体调用的远程方法的IP,端口
* 如果有多个那么需要做负载均衡
* 将调用的方法的入参行序列化
* 通过通信将请求发送到远程方法

远程服务收到调用方的请求，它应该:
* 反序列化请求参数
* 定位到实际要调用的方法，传入参数，执行方法
* 按照调用的路径返回结果。

消息队列如何做流量削峰