## 进程和线程的区别
电脑的运行其实是cpu和寄存器以及内存之间的事情。但是cpu的运行速度是极快的，为了让CPU不那么闲，那就需要多个任务轮流来。那么在执行某个任务的时候，当某个任务得到CPU的执行权限，相关的资源必须就位，也就是万事俱备，只欠CPU。所有这些任务都处于就绪状态，然后由操作系统的调度算法，选出其中的一个，让CPU执行。然后就是PC指针指向该任务的起始代码，由CPU开始执行一个一个的指令。

那么在任务切换的时候，cpu要从用户态切换到内核态，用户态的这些状态不可能每次都重新弄一遍，所以需要有个地方来保存这些信息，便于下次进行现场恢复的时候，直接从内核栈直接读取信息。然后CPU加载进来一个上下文，然后开始执行，执行完之后保存，再加载下一个上下文。

那进程就是上下文切换时候程序的执行部分。是运行中程序的描述，也是对应该段CPU执行时间的描述。与之相关的有寄存器组，堆栈空间。不同的进程，这些东西都不一样，所以才能进行区分。

那么线程是什么呢，进程的粒度太大了，每次都要执行上下文的切换。如果说进程是运行在电脑上的软件，那么一个进程不可能只有一条执行逻辑，必定有多个分支和多个程序段。所以程序拿到CPU的时候，是加载上下文，开始执行小段程序a，再执行小段程序b,再执行小段程序c.最后保存上下文。那这里的小段程序a,b,c或者说分支就是线程。它们共享了进程的上下文环境的更小粒度的CPU时间段。CPU在执行的时候,仅仅进行线程上下文的切换,开销要小很多.

进程上下文和线程上下文的切换：
进程切换分两步：
* 切换页目录以使用新的内存空间
* 切换内核栈和硬件上下文
而对于linux来说：进程和线程的最大区别就是内存地址空间，对于线程来说第一步是不需要的。所以切换线程的的开销是比较小的。还有就是，进程上下文切换的时候，会导致处理器缓存全部失效。
同时一旦内存变更的时候，内存缓存页也会被刷新。这会导致内存的访问效率低下。但是在线程切换中.不会有这个问题。

一句话描述：
    进程是软件程序的一次执行过程，是一个动态概念，是程序在执行过程中分配和管理资源的基本单位。
    线程是CPU调度和分派的基本单位，它可与同属一个进程的其他线程共享进程的全部资源。这些线程在执行的时候是可以并发执行的。

### 常见的线程模型
* 用户级线程模型 此模型下的线程是由用户态线程模型全权管理的,对于操作系统可见的是只是进程，优点是管理简单，但是并不能真正的实现并发，因为对于操作系统暴露的只是进程，操作系统只能对进程多调取
* 内核级线程模型 该模型下的线程全部是内核级线程，线程是由内核态线程模型全权管理的，但是这么多的线程要由内核态权限管理，每次操作都要有内核态的系统调用来操作。这会对操作系统造成很大的不稳定因素
* 两级线程模型 此模型下的一个进程可以对应多个调度器，而进程中的线程和调取器并不是一一对应的。首先加载到内存中的实现两级线程模型的线程库会创建多个内核级的线程。然后通过这些内核级的线程对应用程序进行调度。优点是线程调度更加灵活，并发性也高，缺点是管理难度增大，线程的调度需要内核态和用户态配合管理。因为两级线程模型实现的复杂度,往往不会被操作系统开发者采纳。但是这样的设计模式可以很好的在编程语言的层面实现。所以go就采纳了这种线程并发模型。

### GO程序的并发调度
M: 可以理解为就是GO程序可用的内核态线程
P: go程序运行的上下文
G: go程序对可并发执行的代码的封装

一个P和M关联之后，就可以理解为是获取了一个G的可运行环境。每个P会绑定一个可运行的G队列,获得执行时机的时候。队列中的G会依次传递给P绑定的M.

M和调取器的对应关系是一一对应，且绑定关系是稳定的。虽然M和P的绑定关系也是一一对应的，但是他们之间的绑定关系是不稳固的。如果一个M因为执行P中的G导致系统调用而阻塞。运行是系统就会解除P和M的绑定。如果这时候P的G队列还有可运行的G，就会拿到一个G与空闲的M进行绑定，如果没有就会再创建一个M出来。

说到这里就不得不说到一个函数：runtime.GoMAXPROCS.源码对这个函数的注释说，改函数的作用是设置可同时执行Go程序的最大CPU的数量，我一直想不通。用户态可以控制运行软件的CPU的数量么。完全不可能。但是后来看书，理解到这个函数是用来控制P的数量的。这个就比较好理解了。因为P是go程序运行的上下文。且p和真正的调取单位M是一一绑定的。如果运行时系统控制同一时刻只有一个P能运行。那其实就相当于控制了同一时刻运行Go程序的CPU只有一个。

然后再说M的数量的控制，M的初始值是10000个。也就是说理想情况下，可以有10000个内核级线程并发调度。这个值可以通过
runtime/debug.setMaxThreads进行设置。

M0和G0：
    每个M都会绑定一个特殊的线程G0,用于调度管理，来及回收，堆栈管理等。除了每个M绑定的G0以外，还有一个runtime.go.这个Go是用来执行引导程序的。所以它可以理解为go程序运行所间接拥有的第一个线程，所以也被称作M0.




