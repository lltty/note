事实上，编译好的可执行文件真正的入口并非main.main，而是runtime包下面对应的不同操作系统的rt0文件，因为编译器总是会插入一段引导代码，完整一些初始化动作。

首先运行的是对应平台的rt0文件，这里会做命令行参数处理，操作系统的处理处理，一些初始化工作。命令行参数处理主要是对命令行传参的标准化，操作系统的处理是获取了下cpu核数，这里主要的是初始化，schedinit函数。这个函数里面做的工作是：栈的初始化，内存分配器的初始化，调度器的初始化，处理命令行参数和环境变量，处理调试相关的设置。gc初始化。

然后是确定P的数量，确定这个p的数量是先获取cpu核数，再获取GOMaxprocs，如果GOMaxprocs没有，就使用cpu核数，如果有，那看这个数字是否比常量_MaxGomaxprocs还大，如果比它大，那么使用常量值，如果否，那么使用设定的值。然后再用这个值设置P的数量。

这些初始化工作完了之后，就该运行runtime.main了。而runtime.main运行的是runtime包下面的proc.go.这个文件的main函数里面设置执行栈的最大限制，启动后台监控(gc监控，调度器信息等等)，执行runtime_inittask(runtime包里面所有的初始化函数)，启动垃圾回收，执行main_inittask(用户包所有的初始化函数)，执行main_main(用户入口逻辑)