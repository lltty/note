## 前言
尽量避免创建大对象，也尽量避免频繁创建对象。这个道理在所有待gc的编程语言也都是通用的。

## 版本迭代
1.3以前，固定时间或者垃圾达到阀值时候垃圾回收，这时候会暂停程序。垃圾回收完毕之后，再启动，也就是常说的stw(stop the world),这样垃圾回收时候会严重影响请求。
1.3版本，清理时间的规则不变，但是修改为并发清理
1.4版本，以前的垃圾回收是依赖c的实现，修改为golang自己实现，垃圾回收的精度更高
1.5版本，使用三色标记法进行垃圾回收。期初所有的对象都是白色。从根节点开始遍历，找出可达对象，标记为灰色。之后遍历灰色集合，将灰色对象引用的对象(可达对象)从白色集合放入灰色集合，当该对象所有的可达对象都被标记为灰色之后，将此对象标记为黑色。之后重复这个操作，直到灰色中无任何对象。通过write-barrier(写入屏障)检测对象是否有变化。清除所有白色对象。清除的时候，扫描整个堆内存，发现是活跃对象的话，清除掉它的灰色标记，如果是非活跃对象，链接到空闲链表。便于下次分配，并不会真正的垃圾回收。这样会产生很多的空闲碎片，所以就需要内存分配器合并连续的多余空闲链表。
    什么是可达对象，就是根节点指向某个堆上的对象，那就是可达对象。
    这个算法可以实现，在程序执行的同时进行垃圾回收，并不需要暂停程序。
    gc的触发有个阀值，这个阀值会随着每次内存使用的变大而逐渐变大，所以对导致gc延迟。如果长时间没有出发gc，那么go会主动出发一次(2 min)。高峰时候内存使用量持续上身，靠阀值触发已经基本不可能，而要要等到2 min主动触发。
    go语言向系统交换内存时，操作系统会采取拖延策略，并不是立即回收，而是等到系统真正内存吃紧时候才会回收，这样便于程序重新申请内存时候速度较快。
    这种三色标记法会导致问题。标记是并发执行的，程序在运行期间，如果已经被标记为黑色的对象，又引用了一个新创建的白色对象，但是黑色对象已经被标记过。这样白色对象就会被认为是不可达对象，会被回收。这时候就需要引入写入屏障的概念(golang版本1.8引入)
    
## 写入屏障
   写入屏障的作用就是对标记漏掉的对象进行处理。当一个老变量指向新创建的变量的时候，老变量如果被标记为黑色，那么就会被置为灰色，这样老变量就会被扫描，新的白色变量也会被扫描.对于引用的变更，当有指针删除操作的时候，如果删除的指针指向的白色的对象，那么就会把这个白色的对象直接标记为灰色。