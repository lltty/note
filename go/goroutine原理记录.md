## Goroutine的原理介绍
    每个系统级线程都会有一个固定大小的的栈(一般默认可能是2MB)，这个栈主要用来保存函数递归调用时参数和局部变量。固定了栈的大小导致了两个问题：

    2.1 对于很多只需要很小的栈空间的线程来说是一个巨大的浪费
    2.2 对于少数需要巨大栈空间的线程来说又面临栈溢出的风险。

    Goroutine会以一个很小的栈启动(可能是2KB或4KB)，当遇到深度递归导致栈空间不足时，Goroutine会根据需要动态的伸缩栈的大小(主流实现中栈的大小可达到1G)。因为启动的代价很小，我们可以启动成千上万个Goroutine.

    GO运行时包含了自己的调度器，这个调度器使用了一些技术手段，可以在n个操作系统线程上多工调度m个Goroutine.Go调度器的工作和内核的调度是相似的，但是这个调度器只关注单独的Go程序中的Goroutine。

    Goroutine采用的是半抢占式的协作调度，只有在当前Goroutine发生阻塞时才会导致调度；同时发生在用户态，调度器会根据具体函数只保存必要的寄存器，切换的代码要比系统线程低得多。

    运行时有一个runtime.GOMAXPROCS变量，用于控制当前运行正常非阻塞Goroutine的系统线程数

### 互斥锁和原子操作
    互斥锁的代价比普通整数的原子读写高很多，在性能敏感的地方可以增加一个数字型的标志位，通过原子检测标志位状态来降低互斥锁的使用次数来提高性能。


### go程序函数启动顺序

	在main.main函数执行前所有代码都是在同一个Goroutine中，也就是运行在主系统线程中。如果某个init函数内部用go关键字启动了新的Goroutine的话，新的Goroutine和main.main函数是并发执行的

	Go语言将共享的值通过Channel传递，在任意给定的时刻，最好只有一个Goroutine能够拥有该资源。数据竞争从设计层面上就杜绝了。为了提倡这种思考，Go语言将并发编程哲学化未一句口号：不要通过共享内存来通信，而是通过通信来共享内存

### 管道
	
	当有多个管道可操作时，select会随机选择一个管道。

### 错误处理
  
     Go语言中大部分函数的代码结构几乎相同，首先是一系列的初始检查，用于防止错误发生，之后是函数的实际逻辑
     