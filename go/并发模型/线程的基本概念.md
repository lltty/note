go语言支持的IPC方法有: 管道、信号、Socket

go语言的并发编程模型在底层是由操作系统提供的线程库来支持的

线程
    
    一个线程可以被看作是某个进程中的一个控制流。一个进程至少会包含一个线程，因为至少会有一个
    控制流持续运行。
    
    一个进程的第一个线程会随着它启动而被创建。这个线程被称为该进程的主线程
    
    一个进程可以包含多个线程，这些线程都是由当前进程中已经存在的线程在执行过程中所执行的相应
    的系统调用创建出来的。
    
    一个线程的声明周期不可能逾越其所属进程的生命周期，也就是说一个线程，需要所属于一个进程。
    
    一个线程的创建是轻量级的，因为进程的很多资源都会被其中的所有线程共享，这些被线程共享的资
    源包括:
    
        ` 
        在当前进程的虚拟内存中存储的代码段、数据段、堆、信号处理函数
        当前进程所持有的文件描述符
        `
    所以创建线程只需要创建自己的线程栈，用来保存自己的私有数据
    
系统调用函数

     pthread_create  创建线程
     pthread_cancel  关闭线程
        负责向对应线程ID的线程发一个关闭请求，并且立即返回，至于何时关闭，是由线程自己决定的
     pthread_join 连接已终止的线程
        该函数会一直阻塞的等待给定Id的那个线程的终止，并把该线程的start函数执行的结果返回给
     调用线程。如果目标线程已经处于终止状态，那么该函数会立即返回。调用线程接过流程控制权继续
     执行后续的代码。如果一个线程是可被连接的，那么在它终止之时就必须被连接，否则就会变成一个
     僵尸线程。僵尸线程不但会浪费系统资源，还会导致进程的可创建线程数被无意义的减少。
     pthread_detach 将一个线程分离
        分离线程意味着该线程不再是一个可被连接的线程。分离线程一般是让操作系统内核在目标线程
     终止时自动进行清理和销毁工作。分离操作是不可逆的。也就是，我们不可能让一个不可被连接的线
     程变回到可连接的状态。不过，对于一个已处于分离状态的线程执行终止操作仍然会起作用。
     
     线程自身也是可以终止和分离的
        在线程的start函数中return会使该线程随着start函数的执行结束而终止。
        如果在主线程中return，则所有线程都会终止。或者在任意线程exit,也会如此。
        但是在主线程中pthread_detach，则只会终止主线程。
        线程分离自身和分离其他线程，主要是看传递给函数的线程ID.
        
线程安全性

     如果一个代码它可能被多个线程并发的执行，且总能产生预期的效果，那么就是线程安全的。
     经常被置于线程安全问题中的就是函数，使函数线程安全的标志是可重入。如果一个进程中的所有线程
     都可以并发对一个函数调用，并且无论他们调用改函数的实际执行情况如何，该函数都可以产生预期的
     结果，那么这个函数就是可重入的。
     
     任何内含了对共享数据做操作的函数都可被视为不可重入的。
     
     线程间交换数据是非常简单的，但是却由于其可能发生竞态条件而不得不使用一些同步工具(互斥量)来
     加以保护
     
Go语言同时支持多进程(?)和多线程，但是更倾向于多线程
不同语言倾向于不同的并发编程模型，但是都是在运行性能和维护成本之间的博弈。 

线程实现模型有三种:线程与内核调度实体(KSE)之间的调度关系

     * 用户级线程模型(多对一线程模型):此模型下的线程是由用户级别的线程库全权管理的。线程库并不是内核的一部分。它
     只被存储在进程的用户空间中。进程中的线程的存在对于内核来说是无法感知的。显然，这些线程也不是
     内核的调度器的调度对象。对线程的各种管理和协调完全是用户级程序的自主行为，于内核无关。应用
     程序在对线程进行操作的时候，并不需要从用户态切换到内核态。
        优点:
              1. 因为不存在切换，所以在速度上存在优势。
              2. 对线程的管理不需要内核的参与，所以程序的移植性更强
        缺点： 
              1. 此模型下的多线程并不能够真正的并发,因为线程的管理是用户级程序自主行为，对内核
              而言可见的只有进程。如果这个进程中的一个线程因为I/O操作被阻塞，那么这个进程就会阻塞。
              2. 即使计算机上存在多个CPU,进程中的多个线程也不能分配给不同的CPU运行。对于CPU的负
              载均衡来说，进程的粒度太粗了。因而让不同的进程在不同的CPU上运行的意义也微乎其微
              3. 线程的优先级也形同虚设，因为同一个进程中的线程的优先级只能由进程的优先级决定。
          
     * 内核级线程模型(一对一线程模型): 该模型下的线程是由内核负责管理的。他们是内核的一部分。应用程序对线程的操作都
     必须通过内核提供的系统调用来完成。内核可以对进程的每一个线程进行调度。
        优点: 可以真正实现多线程的并发
        缺点: 内核线程的管理要比用户线程管理的成本高得多。因为线程的管理要不停的在用户态和内核态切换。这样对给调度器
        造成非常大的负担，甚至会影响到整个操作系统的稳定性。所以通常内核级线程模型对一个进程所能创建的线程数是有限制的
     * 两级线程模型(多对多线程模型):次模型下的一个进程可以多个KSE对应，这个内核级线程模型是一样的。但是与内核级线程
     模型不同的是,进程中的线程(应用程序线程)并不与KSE一一对应。
            首先，已被加载到进程的虚拟内存中的实现两级线程模型的线程库会通过操作系统内核创建多个内核级线程。
            然后，它再通过这些内核级线程对应用程序线程进行调度。
            大多数此类线程库都都可以为实际运行的应用程序线程动态的分配若干个内核级线程。
         缺点: 这样的设计使得线程的管理工作更加复杂，因为需要内核和线程库的共同管理才能实现
         优点: 
                1. 内核资源的消耗得以得以大大减少
                2. 线程管理操作的效能得到提高，虽然操作变多了
         因为两级线程模型实现的复杂性，往往不会被操作系统级的开发者采纳。但是，这样的设计模型可以很好的在编程语言的层面
         实现。go的具体实现更加高级和优雅一些。在go的并发编程模型中，不受操作系统内核管理的独立控制流并不被叫做线程，而
         被叫做goroutine.
    
    

